
import React from 'react';

export const contractTypes = [
  { value: 'agreement', label: 'Service Agreement' },
  { value: 'escrow', label: 'Escrow Contract' },
  { value: 'nft', label: 'NFT Marketplace' },
  { value: 'dao', label: 'DAO Governance' },
  { value: 'defi', label: 'DeFi Protocol' },
  { value: 'custom', label: 'Custom Contract' },
];

export const blockchains = [
  { value: 'ethereum', label: 'Ethereum', currency: 'ETH', explorer: 'https://etherscan.io/tx/' },
  { value: 'polygon', label: 'Polygon', currency: 'MATIC', explorer: 'https://polygonscan.com/tx/' },
  { value: 'binance', label: 'Binance Smart Chain', currency: 'BNB', explorer: 'https://bscscan.com/tx/' },
  { value: 'solana', label: 'Solana', currency: 'SOL', explorer: 'https://explorer.solana.com/tx/' },
  { value: 'avalanche', label: 'Avalanche', currency: 'AVAX', explorer: 'https://snowtrace.io/tx/' },
];

export const generateContractCode = (formData) => {
  const contractName = formData.contractName.replace(/\s+/g, '') || 'MyContract';
  const description = formData.description || 'A smart contract generated by HALF-CHAIN';
  
  let specificFunctions = '';
  if (formData.contractType === 'escrow') {
    specificFunctions = `
    function deposit() public payable whenActive ${formData.enableKYC ? 'onlyVerified' : ''} {
        balances[msg.sender] += msg.value;
        emit EscrowDeposit(msg.sender, msg.value);
    }
    
    function releaseFunds(address payable recipient) public onlyOwner whenActive {
        uint256 amount = address(this).balance;
        require(amount > 0, "No funds to release");
        // Additional logic for escrow conditions would be here
        recipient.transfer(amount);
        emit EscrowRelease(recipient, amount);
    }`;
  } else if (formData.contractType === 'nft') {
    specificFunctions = `
    // Basic NFT minting function (simplified)
    uint256 public tokenIdCounter;
    mapping(uint256 => address) public tokenOwner;
    event NFTMinted(address indexed owner, uint256 indexed tokenId);

    function mintNFT(address recipient) public onlyOwner whenActive returns (uint256) {
        tokenIdCounter++;
        tokenOwner[tokenIdCounter] = recipient;
        emit NFTMinted(recipient, tokenIdCounter);
        return tokenIdCounter;
    }`;
  } else if (formData.contractType === 'dao') {
     specificFunctions = `
    struct Proposal {
        uint256 id;
        string description;
        uint256 voteCount;
        bool executed;
    }
    uint256 public proposalCounter;
    mapping(uint256 => Proposal) public proposals;
    mapping(address => mapping(uint256 => bool)) public hasVoted;
    event ProposalCreated(uint256 id, string description);
    event Voted(address indexed voter, uint256 proposalId);

    function createProposal(string memory _description) public whenActive ${formData.enableKYC ? 'onlyVerified' : ''} {
        proposalCounter++;
        proposals[proposalCounter] = Proposal(proposalCounter, _description, 0, false);
        emit ProposalCreated(proposalCounter, _description);
    }

    function vote(uint256 proposalId) public whenActive ${formData.enableKYC ? 'onlyVerified' : ''} {
        require(proposals[proposalId].id != 0, "Proposal does not exist");
        require(!hasVoted[msg.sender][proposalId], "Already voted");
        // Add voting power logic if needed
        proposals[proposalId].voteCount++;
        hasVoted[msg.sender][proposalId] = true;
        emit Voted(msg.sender, proposalId);
    }`;
  }


  return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ${contractName}
 * @dev ${description}
 * @notice Parties involved: ${formData.parties || 'Not specified'}
 * @notice Key terms: ${formData.terms || 'Not specified'}
 */
contract ${contractName} {
    address public owner;
    bool public isActive = true;
    
    mapping(address => bool) public verifiedParties;
    mapping(address => uint256) public balances; // General purpose balances
    
    event ContractActivated(address indexed by);
    event ContractDeactivated(address indexed by);
    event PartyVerified(address indexed party);
    event TransactionExecuted(address indexed from, address indexed to, uint256 amount);
    ${formData.contractType === 'escrow' ? 
    `event EscrowDeposit(address indexed depositor, uint256 amount);
    event EscrowRelease(address indexed recipient, uint256 amount);` : ''}
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }
    
    modifier whenActive() {
        require(isActive, "Contract is not active");
        _;
    }
    
    ${formData.enableKYC ? `modifier onlyVerified() {
        require(verifiedParties[msg.sender], "KYC verification required for this action");
        _;
    }` : ''}
    
    constructor() {
        owner = msg.sender;
        if (formData.enableKYC) {
            verifiedParties[owner] = true; // Owner is implicitly verified
            emit PartyVerified(owner);
        }
    }
    
    ${formData.enableKYC ? `function verifyParty(address party) public onlyOwner {
        require(!verifiedParties[party], "Party already verified");
        verifiedParties[party] = true;
        emit PartyVerified(party);
    }

    function revokePartyVerification(address party) public onlyOwner {
        require(verifiedParties[party], "Party not verified");
        verifiedParties[party] = false;
        // Consider implications of revoking verification
    }` : ''}
    
    function executeGenericTransaction(address to, uint256 amount) public whenActive ${formData.enableKYC ? 'onlyVerified' : ''} {
        // This is a placeholder for a generic transaction
        // Specific logic depends on contract type and terms
        require(balances[msg.sender] >= amount, "Insufficient balance for generic transaction");
        balances[msg.sender] -= amount;
        balances[to] += amount;
        emit TransactionExecuted(msg.sender, to, amount);
    }
    
    function activateContract() public onlyOwner {
        isActive = true;
        emit ContractActivated(msg.sender);
    }
    
    function deactivateContract() public onlyOwner {
        isActive = false;
        emit ContractDeactivated(msg.sender);
    }
    
    // Additional functions based on contract type
    ${specificFunctions}

    // Fallback function to receive Ether
    receive() external payable {}
    fallback() external payable {}
}`;
};
